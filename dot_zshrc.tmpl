# vim: set filetype=sh :
# shellcheck disable=SC1091
# Profiling
#
# zmodload zsh/zprof

export KEYTIMEOUT=20
export ZSH_DISABLE_COMPFIX=true
export LC_ALL=en_US.UTF-8
export LANG="C.UTF-8"
fpath+=~/.zfunc

{{ if eq .chezmoi.hostname "bigone" }}
export PKG_CONFIG_PATH=/usr/lib/x86_64-linux-gnu/pkgconfig
{{ end }}
# Old performance stuff, I played around with
# autoload -Uz compinit && compinit
# if [[ -n ${ZDOTDIR}/.zcompdump(#qN.mh+24) ]]; then
# 	compinit;
# else
# 	compinit -C;
# fi;

# Enhanced PATH management function
path_prepend() {
  local dir="$1"
  # Only add if directory exists and is not already in PATH
  if [[ -d "$dir" && ":$PATH:" != *":$dir:"* ]]; then
    PATH="$dir:$PATH"
  fi
}

path_append() {
  local dir="$1"
  # Only add if directory exists and is not already in PATH
  if [[ -d "$dir" && ":$PATH:" != *":$dir:"* ]]; then
    PATH="$PATH:$dir"
  fi
}

# Remove duplicates from PATH
dedupe_path() {
  local new_path=""
  local IFS=':'
  for dir in $PATH; do
    if [[ -n "$dir" && ":$new_path:" != *":$dir:"* ]]; then
      if [[ -z "$new_path" ]]; then
        new_path="$dir"
      else
        new_path="$new_path:$dir"
      fi
    fi
  done
  PATH="$new_path"
}

# Build PATH systematically
# High priority paths (prepend)
path_prepend "$HOME/.local/bin"
path_prepend "$HOME/.cargo/bin"
path_prepend "$HOME/.local/share/bob/nvim-bin"
path_prepend "$HOME/.claude/local"
path_prepend "$HOME/.opencode/bin"

# Lower priority paths (append)
path_append "/usr/local/cuda/bin"

# Clean up any duplicates (just in case)
dedupe_path

# Export the final PATH
export PATH

# Clean up functions (optional - removes them from environment)
unset -f path_prepend path_append dedupe_path

# export LD_LIBRARY_PATH=/usr/local/cuda/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}
export PYTHONPYCACHEPREFIX=/tmp/pycache
export TEXMFHOME=$HOME/.local/share/texmf
fpath+=${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/plugins/zsh-completions/src

export ZSH="$HOME/.oh-my-zsh"
export ZSH_THEME=${ZSH_THEME:-"robbyrussell"}
export COMPLETION_WAITING_DOTS="true"

export NVM_LAZY_LOAD=true
export NVM_COMPLETION=true
plugins=(git vi-mode dotenv zsh-autosuggestions docker-compose)
zstyle ':omz:plugins:nvm' lazy yes

source "$ZSH/oh-my-zsh.sh"

# Preferred editor for local and remote sessions
export EDITOR='nvim'
export VISUAL='nvim'

bindkey \^K kill-line

# Use standalone scripts for common commands
alias dockerpruneall="$HOME/.local/bin/dockerpruneall.sh"
alias dockerprune="$HOME/.local/bin/dockerprune.sh"
alias hxv="$HOME/.local/bin/hxv.sh"
alias vi="$HOME/.local/bin/vi.sh"

if [ -f ~/.env ]; then
  set -a
  source "$HOME/.env"
  set +a
fi

# alias claude="\$HOME/.claude/local/claude"
alias ncdu="gdu"
alias z="zellij"
alias pac="$HOME/.local/bin/pac.sh"
alias ta="tmux attach"
alias isodate="date -u +%Y-%m-%dT%H:%M:%S%Z"

rclon_ssh() {
  eval "$(ssh-agent -s)" && ssh-add
}
# alias 'gitui'='eval $(ssh-agent) && ssh-add ~/.ssh/id_rsa && gitui && ssh-agent -k'
# alias gu='gitui'
# alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'
# alias cl='lazygit --use-config-file "$HOME/.config/lazygit/tweak.yml" --work-tree ~ --git-dir ~/.cfg'
# alias cz='lazygit --work-tree $HOME/.local/share/chezmoi/'
# alias lz='lazygit'
# alias c="clear"
# if [ -f "/opt/linuxbrew/bin/brew" ]; then
#   eval "$(/opt/linuxbrew/bin/brew shellenv)"
# fi
# if [ -f "/home/linuxbrew/.linuxbrew/bin/brew" ]; then
#   eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
# fi
# alias dp="~/.local/bin/dockerps.sh"
# alias gss="git status -s"
# alias gsl="git status"
# alias nvimdiff='nvim -d'
# alias uy="uv run"
# alias ur="uv run"
#
# function y() {
#   # yazi file manager, but exit to the terminal in the last visited directory within yazi
#   if [ -f "$HOME/.env" ]; then
#     source "$HOME/.env"
#   fi
#   local tmp
#   tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
#   TERM=xterm-kitty yazi "$@" --cwd-file="$tmp" 2>/dev/null
#   if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
#     builtin cd -- "$cwd" || return 1
#   fi
  rm -f -- "$tmp"
}
alias j='y'
alias zrc="chezmoi edit ~/.zshrc"

# alias ap="sudo apt-get update; sudo apt-get upgrade; sudo apt-get autoremove "
alias ap="$HOME/.local/bin/ap.sh"
alias f="cd ~ && cd \$(find * -type d | fzf)"
alias dropboxmama="rclone mount dropboxmama: ~/mnt --daemon --vfs-cache-mode writes --dropbox-encoding 'Slash,BackSlash,Del,RightSpace,InvalidUtf8,Dot,LeftPeriod' -vv"

if [ -x /usr/bin/dircolors ]; then
  test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
  alias ls='ls --color=auto'
fi

# NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"
# export NVM_DIR

# NOTE: I don't why this is needed for anything, but it slows down everything
# [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" # This loads nvm

setopt completealiases

# Don't (or do, when you switch to the command below) use less for simple
# commands like ls (for oh-my-zsh it's the standard otherwise)
unset LESS
# export LESS=-R

if [[ -f "$HOME/.atuin/bin/env" ]]; then
  . "$HOME/.atuin/bin/env"
fi
if command -v fzf &>/dev/null && fzf --help | grep -- '--zsh' &>/dev/null; then
  eval "$(fzf --zsh)"
fi
if command -v atuin &>/dev/null; then
  eval "$(atuin init zsh --disable-up-arrow)"
fi
if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi
if command -v starship &>/dev/null; then
  eval "$(starship init zsh)"
fi
if command -v uv &>/dev/null; then
  eval "$(uv generate-shell-completion zsh)"
fi
if command -v chezmoi &>/dev/null; then
  eval "$(chezmoi completion zsh)"
fi
if command -v just &>/dev/null; then
  # autoload -Uz compinit && compinit
  eval "$(just --completions zsh)"
fi

IFS=',' read -r -A services <<<"$RCLONE_SERVICES"

rc_stop() {
  # Loop through each service name
  for service in "${services[@]}"; do
    echo "stopping rclone@$service.service"
    systemctl --user stop "rclone@$service.service"
    systemctl --user disable "rclone@$service.service"
  done
}

rc_start() {
  # Loop through each service name
  for service in "${services[@]}"; do
    echo "reloading systemd"
    systemctl --user daemon-reload
    echo "enabling rclone@$service.service"
    systemctl --user enable "rclone@$service.service"
    echo "starting rclone@$service.service"
    systemctl --user restart "rclone@$service.service"
  done
}

rc_status() {
  echo "Service            Status"
  echo "--------------------------------"
  for service in "${services[@]}"; do
    mystatus=$(systemctl --user is-active "rclone@$service.service" 2>/dev/null)
    printf "%-20s %s\n" "$service" "$mystatus"
  done
}

rc_log() {
  journalctl --user -u "rclone@*" $1
}

IFS=',' read -r -A sservices <<<"$RSYNC_SERVICES"

rs_do() {
  echo "$HOME/.config/systemd/user/rsync.sh $1 $2"
  $HOME/.config/systemd/user/rsync.sh $1 $2
}

rs_start() {
  # Loop through each service name
  for service in "${sservices[@]}"; do
    echo "reloading systemd"
    systemctl --user daemon-reload
    echo "enabling rsync@$service.service"
    systemctl --user enable "rsync@$service.service"
    echo "starting rsync@$service.timer"
    systemctl --user start "rsync@$service.timer"
    # echo "starting rsync@$service.service"
    # systemctl --user restart "rsync@$service.service"
  done
}

rs_stop() {
  for service in "${sservices[@]}"; do
    echo "stopping rsync@$service.service"
    systemctl --user stop "rsync@$service.service"
    echo "stopping rsync@$service.timer"
    systemctl --user stop "rsync@$service.timer"
  done
}

rs_sync() {
  for service in "${sservices[@]}"; do
    echo "starting rsync@$service.service"
    systemctl --user restart "rsync@$service.service"
  done
}

rs_status() {
  echo "Service            Status               Timer"
  echo "------------------------------------------------"
  for service in "${sservices[@]}"; do
    mystatus=$(systemctl --user is-active "rsync@$service.service" 2>/dev/null)
    tstatus=$(systemctl --user is-active "rsync@$service.timer" 2>/dev/null)
    printf "%-19s%-21s%s\n" "$service" "$mystatus" "$tstatus"
  done
}

rs_log() {
  journalctl --user -u "rsync@*" $1
}

function current_dir() {
  local current_dir=$PWD
  if [[ $current_dir == $HOME ]]; then
    current_dir="~"
  else
    current_dir=${current_dir##*/}
  fi

  echo $current_dir
}

function change_tab_title() {
  local title=$1
  command nohup zellij action rename-tab $title >/dev/null 2>&1
}

function set_tab_to_working_dir() {
  local result=$?
  local title=$(current_dir)
  # uncomment the following to show the exit code after a failed command
  # if [[ $result -gt 0 ]]; then
  #     title="$title [$result]"
  # fi

  change_tab_title $title
}

function set_tab_to_command_line() {
  local cmdline=$1
  local truncated_cmdline=$(echo "$cmdline" | cut -c 1-12)
  change_tab_title $truncated_cmdline
}

if [[ -n $ZELLIJ ]]; then
  add-zsh-hook precmd set_tab_to_working_dir
  add-zsh-hook preexec set_tab_to_command_line
fi

# zprof
